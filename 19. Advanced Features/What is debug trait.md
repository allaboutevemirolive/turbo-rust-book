# What is debug trait

What is #[derive(Debug)] in the code below?

```rust
use std::ops;

// Define a custom Point struct
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

// Implement the Add trait for Point, overloading the '+' operator
impl ops::Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    let point1 = Point { x: 2, y: 3 };
    let point2 = Point { x: 4, y: 1 };

    let sum = point1 + point2;  // '+' operator is overloaded

    println!("{:?}", sum);  // Output: Point { x: 6, y: 4 }
}
```
___


In the code example above, `#[derive(Debug)]` is a Rust attribute used to automatically generate a default implementation of the `Debug` trait for the `Point` struct. The `Debug` trait enables the printing of the struct in a formatted and human-readable way.

When you derive the `Debug` trait using the `#[derive(Debug)]` attribute, Rust automatically generates the necessary code to implement the `Debug` trait's methods for the struct. This includes the `fmt::Debug` implementation, which allows you to use the `{:?}` format specifier in the `println!` macro to print the struct.

By deriving `Debug` for a struct, you get a default implementation that prints the struct's fields and their values when using the `{:?}` format specifier. It's a convenient way to quickly inspect the content of a struct during development and debugging.

Here's an example to illustrate the usage of `Debug` and `#[derive(Debug)]`:

```rust
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let point = Point { x: 2, y: 3 };
    println!("{:?}", point);  // Output: Point { x: 2, y: 3 }
}
```

In this example, we derive the `Debug` trait for the `Point` struct using `#[derive(Debug)]`. Then, inside the `main` function, we create a `Point` instance named `point`. We use the `println!` macro with the `{:?}` format specifier to print the `point` struct. The output will display the struct's fields and their values, as generated by the derived `Debug` implementation.

The `#[derive(Debug)]` attribute is just one example of how attributes can be used in Rust to automatically derive implementations of various traits for your custom types. Other commonly used derived traits include `Clone`, `Eq`, `PartialEq`, `PartialOrd`, and more. These derived traits provide default implementations for certain common behaviors, reducing the need for manual implementation.